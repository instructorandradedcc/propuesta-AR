<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PROPUESTA en SALUD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <!-- CORREGIDO: Versión de Three.js alineada con la del ejemplo funcional para evitar conflictos. -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
            }
        }
    </script>
    
    <style>
        html.ar-active, body.ar-active { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; }
        #app { transition: all 0.3s ease-in-out; }
        .app-container.ar-fullscreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; max-height: none; padding: 0; margin: 0 !important; border-radius: 0; overflow: hidden; }
        .page { display: none; }
        .page.active { display: block; }
        #editor-canvas { width: 100%; height: 400px; border: 1px solid #ccc; background: #f0f0f0; cursor: move; touch-action: none; border-radius: 8px; }
        #ar-scene-container.ar-active { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9990; }
        #ar-scene-container.ar-active a-scene { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ar-scene-container.ar-active video, #ar-scene-container.ar-active canvas { position: absolute !important; top: 50% !important; left: 50% !important; transform: translate(-50%, -50%) !important; min-width: 100% !important; min-height: 100% !important; width: auto !important; height: auto !important; object-fit: cover !important; cursor: grab; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #scanning-ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9991; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: none; background-color: rgba(0,0,0,0.3); transition: opacity 0.3s; }
        #scanning-ui.hidden { opacity: 0; pointer-events: none; }
        .scan-text { margin-top: 24px; padding: 8px 16px; background-color: rgba(0,0,0,0.5); color: white; font-size: 1.1rem; border-radius: 8px; text-shadow: 1px 1px 2px black; }
        #ar-active-controls { position: fixed; bottom: 0; left: 0; width: 100%; z-index: 9999; }
        #debug-info { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px; font-size: 10px; max-width: 300px; max-height: 100px; overflow-y: auto; z-index: 10000; border-radius: 4px; font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body class="bg-gray-200 text-gray-800 font-sans">
    <div id="app" class="relative app-container container mx-auto p-6 md:p-8 max-w-5xl bg-white rounded-xl shadow-lg my-8 overflow-y-auto" style="max-height: 85vh;">
        <div id="version-tag" class="absolute top-2 right-4 text-xs text-gray-400">v3.3-corregido</div>

        <div class="flex justify-center items-center mb-6">
             <img src="https://raw.githubusercontent.com/instructorandradedcc/propuesta-AR/main/logofundacion.jpg" alt="Logo Prototipo" class="h-20 w-auto mr-4" onerror="this.onerror=null;this.src='https://placehold.co/120x80/e2e8f0/94a3b8?text=Logo';">
             <div>
                 <h1 class="text-4xl font-bold text-center" style="color: #1e3a8a;">PROPUESTA en SALUD</h1>
                 <p class="text-center text-gray-500">Visualización de modelos anatómicos con Realidad Aumentada.</p>
             </div>
        </div>
        
        <div id="page-upload" class="page active bg-white p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Paso 1: Cargar Recursos</h2>
            <div id="welcome-box" class="bg-indigo-50 border-l-4 border-indigo-500 text-indigo-700 p-4 mb-6" role="alert">
                <p class="font-bold">¡Bienvenido!</p>
                <p>Presiona el botón para descargar los recursos desde el repositorio. Si tienes problemas, revisa la consola del navegador (F12) y el panel de depuración.</p>
            </div>
            <div class="mt-6 flex flex-col items-center gap-4">
                <button id="load-from-github-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition duration-300 text-lg shadow-md">
                    Cargar Recursos Anatómicos
                </button>
                <button id="clear-cache-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 text-sm shadow-md hidden">
                    Limpiar Caché
                </button>
            </div>
            <div id="loading-status" class="mt-6 hidden">
                <div class="flex justify-center items-center"><div class="loader"></div></div>
                <p id="loading-text" class="text-center text-gray-600 mt-2">Iniciando...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                    <div id="loading-progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="image-preview-container" class="mt-6"></div>
             <div class="mt-8 text-center">
                <button id="goto-editor-btn" disabled class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition duration-300 disabled:bg-gray-300 mt-2">Siguiente: Editar Modelos 3D</button>
            </div>
        </div>

        <div id="page-editor" class="page bg-white p-6 rounded-lg shadow-md">
             <h2 class="text-2xl font-semibold mb-4 border-b pb-2">Paso 2: Ajustar Modelos 3D</h2>
             <div class="bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 mb-6 text-sm" role="alert">
                 <p class="font-bold">Controles:</p>
                 <ul class="list-disc list-inside mt-1">
                     <li><strong>Mover Modelo:</strong> Arrastra el modelo con el ratón o un dedo.</li>
                     <li><strong>Orbitar/Zoom:</strong> Arrastra con el botón izquierdo o usa dos dedos.</li>
                     <li><strong>Rotar Modelo:</strong> Arrastra con el botón derecho del ratón.</li>
                 </ul>
             </div>
            <div class="flex flex-col md:flex-row gap-6">
                <div class="md:w-1/3">
                    <label for="asset-selector" class="block mb-2 font-medium text-gray-700">Seleccionar Recurso:</label>
                    <select id="asset-selector" class="w-full p-2 border rounded mb-4"></select>
                    <h3 class="font-semibold mt-4">Posición (X, Y, Z)</h3>
                    <div class="grid grid-cols-3 gap-2">
                        <input type="number" id="pos-x" class="w-full p-1 border rounded" step="0.01" value="0">
                        <input type="number" id="pos-y" class="w-full p-1 border rounded" step="0.01" value="0">
                        <input type="number" id="pos-z" class="w-full p-1 border rounded" step="0.01" value="0">
                    </div>
                    <h3 class="font-semibold mt-4">Rotación (X, Y, Z)</h3>
                     <div class="grid grid-cols-3 gap-2">
                        <input type="number" id="rot-x" class="w-full p-1 border rounded" step="1" value="0">
                        <input type="number" id="rot-y" class="w-full p-1 border rounded" step="1" value="0">
                        <input type="number" id="rot-z" class="w-full p-1 border rounded" step="1" value="0">
                    </div>
                    <h3 class="font-semibold mt-4">Escala</h3>
                    <input type="number" id="scale" class="w-full p-1 border rounded" step="0.1" value="1">
                </div>
                <div class="md:w-2/3">
                    <div id="editor-container"><canvas id="editor-canvas"></canvas></div>
                </div>
            </div>
            <div class="mt-6 flex justify-between">
                <button id="back-to-upload-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition duration-300">Atrás</button>
                <button id="goto-ar-btn" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition duration-300">Siguiente: Probar AR</button>
            </div>
        </div>

        <div id="page-ar" class="page">
             <div class="relative">
                 <div id="ar-ui-container" class="relative z-10">
                     <h2 class="text-2xl font-semibold mb-4 text-center">Paso 3: Vista de Realidad Aumentada</h2>
                     <div class="bg-white p-4 rounded-lg shadow-md mb-4">
                         <p class="text-center">Apunta tu cámara a una de las imágenes de los marcadores.</p>
                         <div id="ar-status" class="text-center font-mono p-2 bg-gray-100 rounded mt-2 flex justify-center items-center gap-2">
                             <div class="loader hidden"></div>
                             <span id="ar-status-text">Estado: Esperando cámara...</span>
                         </div>
                     </div>
                     <div class="mt-6 flex justify-between items-center">
                         <button id="back-to-editor-btn-pre" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition duration-300">Atrás</button>
                         <button id="start-ar-btn" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 transition duration-300">Activar Cámara AR</button>
                     </div>
                 </div>
                 <div id="ar-preload-container" class="hidden"></div>
                 <div id="ar-scene-container"></div>
                 <div id="scanning-ui" class="hidden">
                     <p class="scan-text">Apunte al marcador</p>
                 </div>
                 <div id="ar-active-controls" class="hidden p-4 bg-black bg-opacity-50">
                     <div class="flex justify-center items-center max-w-4xl mx-auto">
                         <button id="stop-ar-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition duration-300">Detener Cámara</button>
                     </div>
                 </div>
             </div>
        </div>
    </div>
    
    <div id="debug-info"></div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DragControls } from 'three/addons/controls/DragControls.js';

        document.addEventListener('DOMContentLoaded', () => {
            const state = { assets: [], currentPage: 'page-upload', isArActive: false, areAssetsPreloaded: false };
            let editor = { scene: null, camera: null, renderer: null, controls: null, dragControls: null, loader: new GLTFLoader(), textureLoader: new THREE.TextureLoader(), currentTarget: null, currentPlane: null };
            let isRotating = false; 

            const CACHE_NAME = 'propuesta-salud-ar-cache-v3.1';
            const GITHUB_BASE_URL = 'https://raw.githubusercontent.com/instructorandradedcc/propuesta-AR/main/asetss/';
            const ASSET_NAMES = [ 'cabeza1', 'corazon', 'dedo-mano', 'dedo', 'hueso-columna', 'huesosmano', 'mano-iz-protesis', 'protesis-mano-brazo' ];

            // --- Sistema de Depuración ---
            function debugLog(message) {
                console.log(`[DEBUG] ${message}`);
                const debugEl = document.getElementById('debug-info');
                if (debugEl) {
                    debugEl.textContent += message + "\n";
                    debugEl.scrollTop = debugEl.scrollHeight;
                }
            }

            // --- FUNCIONES DE CARGA Y CACHÉ ---
            async function fetchWithCache(url) {
                const cache = await caches.open(CACHE_NAME);
                const cachedResponse = await cache.match(url);
                if (cachedResponse) {
                    debugLog(`Cargado desde caché: ${url.split('/').pop()}`);
                    return cachedResponse;
                }
                debugLog(`Descargando: ${url.split('/').pop()}`);
                const networkResponse = await fetch(url);
                if (networkResponse.ok) {
                    await cache.put(url, networkResponse.clone());
                }
                return networkResponse;
            }

            function displayLoadedImages(assets) {
                const container = document.getElementById('image-preview-container');
                container.innerHTML = `<h3 class="text-lg font-semibold mb-2 text-center">Imágenes de Marcadores Cargadas</h3>`;
                const grid = document.createElement('div');
                grid.className = 'grid grid-cols-2 md:grid-cols-4 gap-4';
                assets.forEach(asset => {
                    const img = document.createElement('img');
                    img.src = asset.imageDataUrl;
                    img.alt = `Marcador para ${asset.name}`;
                    img.className = 'w-full h-auto object-cover rounded-lg shadow-md';
                    grid.appendChild(img);
                });
                container.appendChild(grid);
            }

            async function validateMarkers() {
                debugLog("Validando archivos .mind...");
                let allValid = true;
                for (const asset of state.assets) {
                    try {
                        const response = await fetch(asset.markerDataUrl);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        debugLog(`- Marcador OK: ${asset.name}`);
                    } catch (error) {
                        console.error(`Error al validar el marcador para ${asset.name}:`, error);
                        debugLog(`- ERROR marcador: ${asset.name}`);
                        alert(`Error al cargar el archivo de marcador para: ${asset.name}. Podría estar corrupto o no disponible.`);
                        allValid = false;
                    }
                }
                if (allValid) debugLog("Todos los marcadores son válidos.");
                return allValid;
            }

            async function loadAssetsFromGitHub() {
                const loadingStatusDiv = document.getElementById('loading-status');
                const loadingText = document.getElementById('loading-text');
                const progressBar = document.getElementById('loading-progress-bar');
                const githubBtn = document.getElementById('load-from-github-btn');
                loadingStatusDiv.classList.remove('hidden');
                githubBtn.disabled = true;
                progressBar.style.width = `0%`;
                progressBar.classList.remove('bg-red-600');
                const totalAssets = ASSET_NAMES.length;
                let loadedCount = 0;
                
                const promises = ASSET_NAMES.map(async (name, index) => {
                    const urls = {
                        marker: `${GITHUB_BASE_URL}markers/${name}.mind`,
                        model: `${GITHUB_BASE_URL}modelss/${name}.glb`,
                        image: `${GITHUB_BASE_URL}imagenes/${name}.png`
                    };
                    
                    const [markerRes, modelRes, imageRes] = await Promise.all([ 
                        fetchWithCache(urls.marker), 
                        fetchWithCache(urls.model), 
                        fetchWithCache(urls.image) 
                    ]);
                    
                    if (!markerRes.ok || !modelRes.ok || !imageRes.ok) {
                        throw new Error(`Falló la descarga de recursos para ${name}. Marcador: ${markerRes.status}, Modelo: ${modelRes.status}, Imagen: ${imageRes.status}`);
                    }
                    
                    const [markerBlob, modelBlob, imageBlob] = await Promise.all([ 
                        markerRes.blob(), 
                        modelRes.blob(), 
                        imageRes.blob() 
                    ]);
                    
                    loadedCount++;
                    progressBar.style.width = `${(loadedCount / totalAssets) * 100}%`;
                    loadingText.textContent = `Cargando ${name}... (${loadedCount}/${totalAssets})`;

                    return {
                        id: index, name: name,
                        markerDataUrl: URL.createObjectURL(markerBlob), 
                        modelDataUrl: URL.createObjectURL(modelBlob), 
                        imageDataUrl: URL.createObjectURL(imageBlob),
                        transform: { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } },
                        hasBeenNormalized: false, normalizationFactor: 1,
                    };
                });

                try {
                    state.assets = await Promise.all(promises);
                    const markersAreValid = await validateMarkers();
                    if (!markersAreValid) {
                        throw new Error("Algunos archivos de marcadores no son válidos. Proceso detenido.");
                    }
                    debugLog("Todos los recursos cargados y validados.");
                    loadingText.textContent = '¡Recursos cargados y guardados en caché!';
                    displayLoadedImages(state.assets);
                    document.getElementById('goto-editor-btn').disabled = false;
                    document.getElementById('clear-cache-btn').classList.remove('hidden');
                    setTimeout(() => { loadingStatusDiv.classList.add('hidden'); }, 1500);
                } catch (error) {
                    loadingText.textContent = 'Error al cargar recursos. Revisa la consola y el panel de depuración.';
                    progressBar.classList.add('bg-red-600');
                    console.error("Fallo en la carga de recursos:", error);
                    debugLog(`ERROR: ${error.message}`);
                } finally {
                    githubBtn.disabled = false;
                }
            }
            
            async function clearCache() {
                try {
                    await caches.delete(CACHE_NAME);
                    alert('Caché limpiada con éxito. La página se recargará.');
                    location.reload();
                } catch (error) {
                    alert('No se pudo limpiar la caché.');
                    console.error('Falló la limpieza de caché:', error);
                }
            }
            
            async function loadAssetsFromCacheOnStartup() {
                try {
                    const cache = await caches.open(CACHE_NAME);
                    const keys = await cache.keys();
                    if (keys.length < ASSET_NAMES.length * 3) throw new Error("Caché incompleto.");
                    
                    state.assets = await Promise.all(ASSET_NAMES.map(async (name, index) => {
                        const urls = { 
                            marker: `${GITHUB_BASE_URL}markers/${name}.mind`, 
                            model: `${GITHUB_BASE_URL}modelss/${name}.glb`, 
                            image: `${GITHUB_BASE_URL}imagenes/${name}.png` 
                        };
                        const [markerRes, modelRes, imageRes] = await Promise.all([ 
                            cache.match(urls.marker), 
                            cache.match(urls.model), 
                            cache.match(urls.image) 
                        ]);
                        if (!markerRes || !modelRes || !imageRes) throw new Error(`Asset ${name} no encontrado en caché.`);
                        
                        const [markerBlob, modelBlob, imageBlob] = await Promise.all([ 
                            markerRes.blob(), 
                            modelRes.blob(), 
                            imageRes.blob() 
                        ]);

                        return {
                            id: index, name: name,
                            markerDataUrl: URL.createObjectURL(markerBlob), 
                            modelDataUrl: URL.createObjectURL(modelBlob), 
                            imageDataUrl: URL.createObjectURL(imageBlob),
                            transform: { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, scale: { x: 1, y: 1, z: 1 } },
                            hasBeenNormalized: false, normalizationFactor: 1,
                        };
                    }));
                    
                    const markersAreValid = await validateMarkers();
                    if (!markersAreValid) {
                        state.assets = []; // Limpiar assets si los marcadores son inválidos
                        throw new Error("Marcadores en caché inválidos.");
                    }
                    
                    return true;
                } catch (error) {
                    debugLog(`No se cargó desde caché: ${error.message}`);
                    return false;
                }
            }

            // --- FUNCIONES DEL EDITOR 3D ---
            function initEditor() {
                const canvas = document.getElementById('editor-canvas');
                const container = document.getElementById('editor-container');
                if (!canvas || !container || editor.renderer) return;

                editor.scene = new THREE.Scene();
                editor.scene.background = new THREE.Color(0xeeeeee);
                editor.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                editor.camera.position.set(0, 1, 15);
                editor.scene.add(new THREE.AmbientLight(0xffffff, 2));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
                directionalLight.position.set(2, 5, 3);
                editor.scene.add(directionalLight);

                editor.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                editor.renderer.setSize(container.clientWidth, container.clientHeight);
                editor.renderer.setPixelRatio(window.devicePixelRatio);

                editor.controls = new OrbitControls(editor.camera, editor.renderer.domElement);
                editor.controls.enableDamping = true;
                const animate = () => { requestAnimationFrame(animate); editor.controls.update(); editor.renderer.render(editor.scene, editor.camera); };
                animate();
            }

            function populateEditorSelector() {
                const assetSelector = document.getElementById('asset-selector');
                assetSelector.innerHTML = '';
                state.assets.forEach(asset => {
                    const option = document.createElement('option');
                    option.value = asset.id;
                    option.textContent = asset.name;
                    assetSelector.appendChild(option);
                });
            }

            function updateTransformInputs(transform) {
                document.getElementById('pos-x').value = transform.position.x.toFixed(2);
                document.getElementById('pos-y').value = transform.position.y.toFixed(2);
                document.getElementById('pos-z').value = transform.position.z.toFixed(2);
                document.getElementById('rot-x').value = Math.round(transform.rotation.x);
                document.getElementById('rot-y').value = Math.round(transform.rotation.y);
                document.getElementById('rot-z').value = Math.round(transform.rotation.z);
                document.getElementById('scale').value = transform.scale.x.toFixed(2);
            }

            function displayAssetInEditor(assetId) {
                const asset = state.assets.find(a => a.id === assetId);
                if (!asset || !editor.scene) return;
                if (editor.currentTarget) editor.scene.remove(editor.currentTarget);
                if (editor.currentPlane) editor.scene.remove(editor.currentPlane);
                if (editor.dragControls) editor.dragControls.dispose();
                
                editor.textureLoader.load(asset.imageDataUrl, (texture) => {
                    const aspect = texture.image.width / texture.image.height;
                    const planeWidth = 10;
                    editor.currentPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeWidth / aspect), new THREE.MeshBasicMaterial({ map: texture }));
                    editor.currentPlane.position.set(0, 0, -0.1);
                    editor.scene.add(editor.currentPlane);
                });

                editor.loader.load(asset.modelDataUrl, (gltf) => {
                    editor.currentTarget = gltf.scene;
                    
                    if (!asset.hasBeenNormalized) {
                        const box = new THREE.Box3().setFromObject(editor.currentTarget);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());
                        asset.normalizationFactor = 1.0 / Math.max(size.x, size.y, size.z);
                        editor.currentTarget.position.sub(center);
                        asset.transform.scale = { x: 5, y: 5, z: 5 }; // Escala inicial por defecto
                        asset.hasBeenNormalized = true;
                    }
                    
                    editor.scene.add(editor.currentTarget);
                    updateModelTransformFromState(asset.transform);
                    updateTransformInputs(asset.transform);
                    setupDragControls(editor.currentTarget);
                }, undefined, (error) => {
                    console.error(`Error loading model ${asset.name}:`, error);
                    alert(`Error al cargar el modelo: ${asset.name}. Puede que el archivo esté corrupto.`);
                });
            }
                
            function updateModelTransformFromState(transform) {
                if (!editor.currentTarget) return;
                const assetId = parseInt(document.getElementById('asset-selector').value);
                const asset = state.assets.find(a => a.id === assetId);
                if (!asset || !asset.normalizationFactor) return;

                const finalScale = transform.scale.x * asset.normalizationFactor;
                
                editor.currentTarget.position.set(transform.position.x, transform.position.y, transform.position.z);
                editor.currentTarget.rotation.set( 
                    THREE.MathUtils.degToRad(transform.rotation.x), 
                    THREE.MathUtils.degToRad(transform.rotation.y), 
                    THREE.MathUtils.degToRad(transform.rotation.z) 
                );
                editor.currentTarget.scale.set(finalScale, finalScale, finalScale);
            }

            function setupDragControls(object) {
                editor.dragControls = new DragControls([object], editor.camera, editor.renderer.domElement);
                editor.dragControls.addEventListener('dragstart', () => { if (!isRotating) editor.controls.enabled = false; });
                editor.dragControls.addEventListener('dragend', (event) => {
                    if (!isRotating) editor.controls.enabled = true;
                    const assetId = parseInt(document.getElementById('asset-selector').value);
                    const asset = state.assets.find(a => a.id === assetId);
                    if (asset) {
                        Object.assign(asset.transform.position, event.object.position);
                        updateTransformInputs(asset.transform);
                    }
                });
            }

            // --- FUNCIONES DE REALIDAD AUMENTADA ---
            function preloadARAssets() {
                if (state.areAssetsPreloaded || state.assets.length === 0) return;
                
                const arStatusText = document.getElementById('ar-status-text');
                const arLoader = document.querySelector('#ar-status .loader');
                arStatusText.textContent = 'Precargando modelos 3D...';
                arLoader.classList.remove('hidden');

                const tempScene = document.createElement('a-scene');
                tempScene.style.cssText = 'position:fixed; height:1px; width:1px; top:-9999px; left:-9999px;';
                document.body.appendChild(tempScene);

                const assetsEl = document.createElement('a-assets');
                assetsEl.setAttribute('timeout', '30000');

                let loadedCount = 0;
                state.assets.forEach(asset => {
                    const assetItem = document.createElement('a-asset-item');
                    assetItem.id = `model-${asset.id}`;
                    assetItem.setAttribute('src', asset.modelDataUrl);
                    // CORREGIDO: Se añade 'response-type' para asegurar que los .glb se traten como archivos binarios.
                    assetItem.setAttribute('response-type', 'arraybuffer');
                    
                    assetItem.addEventListener('loaded', () => {
                        debugLog(`Modelo precargado: ${asset.name}`);
                        loadedCount++;
                        if (loadedCount === state.assets.length) {
                            state.areAssetsPreloaded = true;
                            arStatusText.textContent = '¡Recursos listos! Ya puedes activar la cámara.';
                            arLoader.classList.add('hidden');
                            document.body.removeChild(tempScene);
                        }
                    });
                    
                    assetItem.addEventListener('error', (e) => {
                        console.error(`Error precargando el modelo ${asset.name}:`, e);
                        debugLog(`ERROR precarga: ${asset.name}`);
                        arStatusText.textContent = `Error cargando modelo: ${asset.name}`;
                        arLoader.classList.add('hidden');
                    });
                    
                    assetsEl.appendChild(assetItem);
                });
                
                tempScene.appendChild(assetsEl);
            }

            function startAR() {
                if (!state.areAssetsPreloaded) {
                    alert("Los modelos 3D aún se están cargando. Por favor, espera a que el estado cambie a '¡Recursos listos!'.");
                    return;
                }
                
                debugLog("Iniciando AR con múltiples marcadores...");
                
                const arSceneContainer = document.getElementById('ar-scene-container');
                arSceneContainer.innerHTML = '';
                
                const sceneEl = document.createElement('a-scene');
                sceneEl.setAttribute('embedded', '');
                
                const mindARSettings = `imageTargetSrc: ${state.assets.map(a => a.markerDataUrl).join(';')}; maxTrackables: ${state.assets.length}; autoStart: false; uiLoading: no; uiError: no; uiScanning: no;`;

                sceneEl.setAttribute('mindar-image', mindARSettings);
                sceneEl.setAttribute('color-space', 'sRGB');
                sceneEl.setAttribute('renderer', 'colorManagement: true, physicallyCorrectLights');
                sceneEl.setAttribute('vr-mode-ui', 'enabled: false');
                sceneEl.setAttribute('device-orientation-permission-ui', 'enabled: false');
                
                const cameraEl = document.createElement('a-camera');
                cameraEl.setAttribute('position', '0 0 0');
                cameraEl.setAttribute('look-controls', 'enabled: false');
                sceneEl.appendChild(cameraEl);

                state.assets.forEach((asset, index) => {
                    debugLog(`- Creando target para ${asset.name} (índice: ${index})`);
                    
                    const targetEl = document.createElement('a-entity');
                    targetEl.setAttribute('mindar-image-target', `targetIndex: ${index}`);
                    
                    targetEl.addEventListener('targetFound', () => {
                        debugLog(`Target ENCONTRADO: ${asset.name}`);
                    });
                    
                    targetEl.addEventListener('targetLost', () => {
                        debugLog(`Target PERDIDO: ${asset.name}`);
                    });
                    
                    const t = asset.transform;
                    const finalScale = asset.normalizationFactor * t.scale.x;

                    const modelEntity = document.createElement('a-gltf-model');
                    modelEntity.setAttribute('src', asset.modelDataUrl); 
                    modelEntity.setAttribute('position', `${t.position.x} ${t.position.y} ${t.position.z}`);
                    modelEntity.setAttribute('rotation', `${t.rotation.x} ${t.rotation.y} ${t.rotation.z}`);
                    modelEntity.setAttribute('scale', `${finalScale} ${finalScale} ${finalScale}`);
                    
                    targetEl.appendChild(modelEntity);
                    sceneEl.appendChild(targetEl);
                });

                const scanningUI = document.getElementById('scanning-ui');
                
                sceneEl.addEventListener('loaded', () => {
                    debugLog("Escena AR cargada. Iniciando sistema MindAR...");
                    const mindarSystem = sceneEl.systems['mindar-image-system'];
                    if (mindarSystem) {
                        mindarSystem.start();
                    } else {
                        debugLog("ERROR: No se encontró el sistema mindar-image.");
                        alert("Error crítico: No se pudo inicializar el sistema de Realidad Aumentada.");
                    }
                });
                
                sceneEl.addEventListener('arReady', () => {
                    debugLog("Sistema AR listo. Buscando marcadores...");
                    scanningUI.classList.remove('hidden');
                });
                
                sceneEl.addEventListener('targetFound', () => {
                    scanningUI.classList.add('hidden');
                });
                
                sceneEl.addEventListener('targetLost', () => {
                    scanningUI.classList.remove('hidden');
                });

                arSceneContainer.appendChild(sceneEl);
                arSceneContainer.classList.add('ar-active');
                document.getElementById('ar-ui-container').classList.add('hidden');
                document.getElementById('ar-active-controls').classList.remove('hidden');
                state.isArActive = true;
            }

            function stopAR() {
                const arSceneContainer = document.getElementById('ar-scene-container');
                const sceneEl = arSceneContainer.querySelector('a-scene');
                if (sceneEl && sceneEl.hasLoaded) {
                    if (sceneEl.systems['mindar-image-system']) {
                         sceneEl.systems['mindar-image-system'].stop();
                    }
                    sceneEl.pause();
                    if (sceneEl.parentNode) {
                        sceneEl.parentNode.removeChild(sceneEl);
                    }
                }
                arSceneContainer.innerHTML = '';
                
                state.areAssetsPreloaded = false; 
                document.getElementById('ar-status-text').textContent = "Estado: Esperando cámara...";

                arSceneContainer.classList.remove('ar-active');
                document.getElementById('ar-ui-container').classList.remove('hidden');
                document.getElementById('ar-active-controls').classList.add('hidden');
                state.isArActive = false;
                debugLog("Sistema AR detenido.");
            }

            // --- NAVEGACIÓN Y EVENTOS ---
            function navigateTo(pageId) {
                if (state.isArActive) stopAR();
                document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
                const targetPage = document.getElementById(pageId);
                if (targetPage) targetPage.classList.add('active');
                state.currentPage = pageId;
                
                if (pageId === 'page-editor') {
                    if (!editor.renderer) initEditor();
                    populateEditorSelector();
                    if (state.assets.length > 0) {
                        displayAssetInEditor(parseInt(document.getElementById('asset-selector').value) || 0);
                    }
                } else if (pageId === 'page-ar') {
                    preloadARAssets();
                }
            }
            
            async function initializeApp() {
                debugLog("Inicializando aplicación...");
                const successfullyLoadedFromCache = await loadAssetsFromCacheOnStartup();
                const clearCacheBtn = document.getElementById('clear-cache-btn');
                if (successfullyLoadedFromCache) {
                    debugLog("Recursos cargados desde caché.");
                    document.getElementById('load-from-github-btn').textContent = 'Recargar Recursos';
                    document.getElementById('goto-editor-btn').disabled = false;
                    displayLoadedImages(state.assets);
                    document.querySelector('#welcome-box p').textContent = '¡Recursos cargados desde la caché! Ya puedes continuar o recargarlos si lo deseas.';
                    clearCacheBtn.classList.remove('hidden');
                } else {
                    document.querySelector('#welcome-box p').textContent = 'Presiona el botón para descargar los recursos por primera vez. Se guardarán en la caché para futuras visitas.';
                    clearCacheBtn.classList.add('hidden');
                }
            }

            // --- Event Listeners ---
            document.getElementById('goto-editor-btn').addEventListener('click', () => navigateTo('page-editor'));
            document.getElementById('goto-ar-btn').addEventListener('click', () => navigateTo('page-ar'));
            document.getElementById('back-to-upload-btn').addEventListener('click', () => navigateTo('page-upload'));
            document.getElementById('back-to-editor-btn-pre').addEventListener('click', () => navigateTo('page-editor'));
            document.getElementById('start-ar-btn').addEventListener('click', startAR);
            document.getElementById('stop-ar-btn').addEventListener('click', stopAR);
            
            document.getElementById('load-from-github-btn').addEventListener('click', loadAssetsFromGitHub);
            document.getElementById('clear-cache-btn').addEventListener('click', clearCache);

            const assetSelector = document.getElementById('asset-selector');
            assetSelector.addEventListener('change', (e) => displayAssetInEditor(parseInt(e.target.value)));
            
            ['pos-x', 'pos-y', 'pos-z', 'rot-x', 'rot-y', 'rot-z', 'scale'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    const assetId = parseInt(assetSelector.value);
                    const asset = state.assets.find(a => a.id === assetId);
                    if (!asset || !editor.currentTarget) return;
                    
                    asset.transform.position = { 
                        x: parseFloat(document.getElementById('pos-x').value), 
                        y: parseFloat(document.getElementById('pos-y').value), 
                        z: parseFloat(document.getElementById('pos-z').value) 
                    };
                    asset.transform.rotation = { 
                        x: parseFloat(document.getElementById('rot-x').value), 
                        y: parseFloat(document.getElementById('rot-y').value), 
                        z: parseFloat(document.getElementById('rot-z').value) 
                    };
                    const scaleVal = parseFloat(document.getElementById('scale').value);
                    asset.transform.scale = { x: scaleVal, y: scaleVal, z: scaleVal };
                    
                    updateModelTransformFromState(asset.transform);
                });
            });

            const canvas = document.getElementById('editor-canvas');
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            let previousMousePosition = { x: 0, y: 0 };
            canvas.addEventListener('mousedown', e => {
                if (e.button === 2) { // Right click
                    isRotating = true;
                    editor.controls.enabled = false;
                    if (editor.dragControls) editor.dragControls.enabled = false;
                    previousMousePosition.x = e.clientX;
                }
            });
            canvas.addEventListener('mousemove', e => {
                if (isRotating && editor.currentTarget) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const assetId = parseInt(assetSelector.value);
                    const asset = state.assets.find(a => a.id === assetId);
                    if (!asset) return;

                    asset.transform.rotation.y += deltaX * 0.5; 
                    updateModelTransformFromState(asset.transform);
                    document.getElementById('rot-y').value = Math.round(asset.transform.rotation.y % 360);
                    previousMousePosition.x = e.clientX;
                }
            });
            window.addEventListener('mouseup', e => {
                if (e.button === 2) {
                    isRotating = false;
                    editor.controls.enabled = true;
                    if (editor.dragControls) editor.dragControls.enabled = true;
                }
            });
            
            initializeApp();
        });
    </script>
</body>
</html>


